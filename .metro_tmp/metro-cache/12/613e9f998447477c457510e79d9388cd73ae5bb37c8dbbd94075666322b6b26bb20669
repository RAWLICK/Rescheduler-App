{"dependencies":[{"name":"@motionone/utils","data":{"asyncType":null,"locs":[{"start":{"line":3,"column":12,"index":27},"end":{"line":3,"column":39,"index":54}}],"key":"xckskIHee+cZzkqmegwsQoOgUg0="}}],"output":[{"data":{"code":"__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  'use strict';\n\n  /*\n    Bezier function generator\n  \n    This has been modified from GaÃ«tan Renaudeau's BezierEasing\n    https://github.com/gre/bezier-easing/blob/master/src/index.js\n    https://github.com/gre/bezier-easing/blob/master/LICENSE\n    \n    I've removed the newtonRaphsonIterate algo because in benchmarking it\n    wasn't noticiably faster than binarySubdivision, indeed removing it\n    usually improved times, depending on the curve.\n  \n    I also removed the lookup table, as for the added bundle size and loop we're\n    only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n    to 12 to compensate and this still tended to be faster for no perceivable\n    loss in accuracy.\n  \n    Usage\n      const easeOut = cubicBezier(.17,.67,.83,.67);\n      const x = easeOut(0.5); // returns 0.627...\n  */\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  var calcBezier = function calcBezier(t, a1, a2) {\n    return (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\n  };\n  var subdivisionPrecision = 0.0000001;\n  var subdivisionMaxIterations = 12;\n  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n      currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - x;\n      if (currentX > 0.0) {\n        upperBound = currentT;\n      } else {\n        lowerBound = currentT;\n      }\n    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n  }\n  function cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2) return _$$_REQUIRE(_dependencyMap[0], \"@motionone/utils\").noopReturn;\n    var getTForX = function getTForX(aX) {\n      return binarySubdivide(aX, 0, 1, mX1, mX2);\n    };\n    // If animation is at start/end, return t without easing\n    return function (t) {\n      return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n    };\n  }\n  exports.cubicBezier = cubicBezier;\n});","lineCount":57,"map":[[2,2,1,0],[2,14,1,12],[4,2,5,0],[5,0,6,0],[6,0,7,0],[7,0,8,0],[8,0,9,0],[9,0,10,0],[10,0,11,0],[11,0,12,0],[12,0,13,0],[13,0,14,0],[14,0,15,0],[15,0,16,0],[16,0,17,0],[17,0,18,0],[18,0,19,0],[19,0,20,0],[20,0,21,0],[21,0,22,0],[22,0,23,0],[23,0,24,0],[24,2,25,0],[25,2,26,0],[25,6,26,6,"calcBezier"],[25,16,26,16],[25,19,26,19],[25,28,26,6,"calcBezier"],[25,38,26,16,"calcBezier"],[25,39,26,20,"t"],[25,40,26,21],[25,42,26,23,"a1"],[25,44,26,25],[25,46,26,27,"a2"],[25,48,26,29],[26,4,26,29],[26,11,26,34],[26,12,26,35],[26,13,26,36],[26,14,26,37],[26,17,26,40],[26,20,26,43],[26,23,26,46],[26,26,26,49,"a2"],[26,28,26,51],[26,31,26,54],[26,34,26,57],[26,37,26,60,"a1"],[26,39,26,62],[26,43,26,66,"t"],[26,44,26,67],[26,48,26,71],[26,51,26,74],[26,54,26,77,"a2"],[26,56,26,79],[26,59,26,82],[26,62,26,85],[26,65,26,88,"a1"],[26,67,26,90],[26,68,26,91],[26,72,26,95,"t"],[26,73,26,96],[26,76,26,99],[26,79,26,102],[26,82,26,105,"a1"],[26,84,26,107],[26,88,26,111,"t"],[26,89,26,112],[27,2,26,112],[28,2,27,0],[28,6,27,6,"subdivisionPrecision"],[28,26,27,26],[28,29,27,29],[28,38,27,38],[29,2,28,0],[29,6,28,6,"subdivisionMaxIterations"],[29,30,28,30],[29,33,28,33],[29,35,28,35],[30,2,29,0],[30,11,29,9,"binarySubdivide"],[30,26,29,24,"binarySubdivide"],[30,27,29,25,"x"],[30,28,29,26],[30,30,29,28,"lowerBound"],[30,40,29,38],[30,42,29,40,"upperBound"],[30,52,29,50],[30,54,29,52,"mX1"],[30,57,29,55],[30,59,29,57,"mX2"],[30,62,29,60],[30,64,29,62],[31,4,30,4],[31,8,30,8,"currentX"],[31,16,30,16],[32,4,31,4],[32,8,31,8,"currentT"],[32,16,31,16],[33,4,32,4],[33,8,32,8,"i"],[33,9,32,9],[33,12,32,12],[33,13,32,13],[34,4,33,4],[34,7,33,7],[35,6,34,8,"currentT"],[35,14,34,16],[35,17,34,19,"lowerBound"],[35,27,34,29],[35,30,34,32],[35,31,34,33,"upperBound"],[35,41,34,43],[35,44,34,46,"lowerBound"],[35,54,34,56],[35,58,34,60],[35,61,34,63],[36,6,35,8,"currentX"],[36,14,35,16],[36,17,35,19,"calcBezier"],[36,27,35,29],[36,28,35,30,"currentT"],[36,36,35,38],[36,38,35,40,"mX1"],[36,41,35,43],[36,43,35,45,"mX2"],[36,46,35,48],[36,47,35,49],[36,50,35,52,"x"],[36,51,35,53],[37,6,36,8],[37,10,36,12,"currentX"],[37,18,36,20],[37,21,36,23],[37,24,36,26],[37,26,36,28],[38,8,37,12,"upperBound"],[38,18,37,22],[38,21,37,25,"currentT"],[38,29,37,33],[39,6,38,8],[39,7,38,9],[39,13,39,13],[40,8,40,12,"lowerBound"],[40,18,40,22],[40,21,40,25,"currentT"],[40,29,40,33],[41,6,41,8],[42,4,42,4],[42,5,42,5],[42,13,42,13,"Math"],[42,17,42,17],[42,18,42,18,"abs"],[42,21,42,21],[42,22,42,22,"currentX"],[42,30,42,30],[42,31,42,31],[42,34,42,34,"subdivisionPrecision"],[42,54,42,54],[42,58,43,8],[42,60,43,10,"i"],[42,61,43,11],[42,64,43,14,"subdivisionMaxIterations"],[42,88,43,38],[43,4,44,4],[43,11,44,11,"currentT"],[43,19,44,19],[44,2,45,0],[45,2,46,0],[45,11,46,9,"cubicBezier"],[45,22,46,20,"cubicBezier"],[45,23,46,21,"mX1"],[45,26,46,24],[45,28,46,26,"mY1"],[45,31,46,29],[45,33,46,31,"mX2"],[45,36,46,34],[45,38,46,36,"mY2"],[45,41,46,39],[45,43,46,41],[46,4,47,4],[47,4,48,4],[47,8,48,8,"mX1"],[47,11,48,11],[47,16,48,16,"mY1"],[47,19,48,19],[47,23,48,23,"mX2"],[47,26,48,26],[47,31,48,31,"mY2"],[47,34,48,34],[47,36,49,8],[47,43,49,15,"_$$_REQUIRE"],[47,54,49,15],[47,55,49,15,"_dependencyMap"],[47,69,49,15],[47,94,49,21,"noopReturn"],[47,104,49,31],[48,4,50,4],[48,8,50,10,"getTForX"],[48,16,50,18],[48,19,50,21],[48,28,50,10,"getTForX"],[48,36,50,18,"getTForX"],[48,37,50,22,"aX"],[48,39,50,24],[49,6,50,24],[49,13,50,29,"binarySubdivide"],[49,28,50,44],[49,29,50,45,"aX"],[49,31,50,47],[49,33,50,49],[49,34,50,50],[49,36,50,52],[49,37,50,53],[49,39,50,55,"mX1"],[49,42,50,58],[49,44,50,60,"mX2"],[49,47,50,63],[49,48,50,64],[50,4,50,64],[51,4,51,4],[52,4,52,4],[52,11,52,11],[52,21,52,12,"t"],[52,22,52,13],[53,6,52,13],[53,13,52,18,"t"],[53,14,52,19],[53,19,52,24],[53,20,52,25],[53,24,52,29,"t"],[53,25,52,30],[53,30,52,35],[53,31,52,36],[53,34,52,39,"t"],[53,35,52,40],[53,38,52,43,"calcBezier"],[53,48,52,53],[53,49,52,54,"getTForX"],[53,57,52,62],[53,58,52,63,"t"],[53,59,52,64],[53,60,52,65],[53,62,52,67,"mY1"],[53,65,52,70],[53,67,52,72,"mY2"],[53,70,52,75],[53,71,52,76],[54,4,52,76],[55,2,53,0],[56,2,55,0,"exports"],[56,9,55,7],[56,10,55,8,"cubicBezier"],[56,21,55,19],[56,24,55,22,"cubicBezier"],[56,35,55,33],[57,0,55,34],[57,3]],"functionMap":{"names":["<global>","calcBezier","binarySubdivide","cubicBezier","getTForX","<anonymous>"],"mappings":"AAA;mBCyB,6FD;AEG;CFgB;AGC;qBCI,2CD;WEE,iEF;CHC"}},"type":"js/module"}]}